<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PlusCode Compass Navigator</title>
  <style>
    :root{
      --bg:#0b0f14;
      --card:#111826;
      --muted:#9fb0c2;
      --text:#e8f0f7;
      --danger:#ff5a5f;
      --ok:#34d399;
      --warn:#fbbf24;
      --accent:#60a5fa;
      --ring: rgba(96,165,250,.35);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 800px at 50% 0%, rgba(96,165,250,.12), transparent 55%), var(--bg);
      color:var(--text);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
    }
    .app{
      width:min(720px, 96vw);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid rgba(255,255,255,.07);
      border-radius:22px;
      overflow:hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,.35);
    }
    header{
      padding:16px 18px;
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    header h1{
      font-size:14px;
      margin:0;
      letter-spacing:.4px;
      font-weight:700;
      text-transform:uppercase;
      color:rgba(232,240,247,.92);
    }
    header .pill{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      color:rgba(232,240,247,.85);
      background:rgba(255,255,255,.03);
      display:flex;
      align-items:center;
      gap:8px;
      user-select:none;
    }
    .dot{width:8px;height:8px;border-radius:999px;background:var(--warn);box-shadow:0 0 0 6px rgba(251,191,36,.15)}
    .dot.ok{background:var(--ok);box-shadow:0 0 0 6px rgba(52,211,153,.14)}
    .dot.bad{background:var(--danger);box-shadow:0 0 0 6px rgba(255,90,95,.14)}

    main{ padding:18px; }

    /* Required layout order: input -> button -> distance -> arrow */
    .stack{ display:flex; flex-direction:column; gap:14px; }

    .field{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    label{
      font-size:12px;
      color:rgba(232,240,247,.75);
    }
    input{
      width:100%;
      padding:14px 14px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(17,24,38,.75);
      color:var(--text);
      outline:none;
      font-size:16px;
    }
    input:focus{ border-color:rgba(96,165,250,.55); box-shadow:0 0 0 6px var(--ring); }

    .actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    button{
      padding:12px 14px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:var(--text);
      font-weight:700;
      font-size:14px;
      cursor:pointer;
      transition: transform .05s ease, background .2s ease, border .2s ease;
      user-select:none;
    }
    button:hover{ background:rgba(255,255,255,.09); }
    button:active{ transform: translateY(1px); }
    button.primary{
      background: linear-gradient(180deg, rgba(96,165,250,.95), rgba(59,130,246,.85));
      border-color:rgba(96,165,250,.85);
      color:#06101d;
    }
    button.primary:disabled{
      opacity:.55;
      cursor:not-allowed;
      filter:saturate(.6);
    }
    button.ghost{ background:transparent; }

    .status{
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(17,24,38,.45);
      color:rgba(232,240,247,.86);
      font-size:13px;
      line-height:1.35;
    }
    .status strong{ color:rgba(232,240,247,.95); }
    .status.ok{ border-color:rgba(52,211,153,.25); background:rgba(52,211,153,.07); }
    .status.warn{ border-color:rgba(251,191,36,.22); background:rgba(251,191,36,.06); }
    .status.bad{ border-color:rgba(255,90,95,.22); background:rgba(255,90,95,.06); }

    .distance{
      padding:14px 14px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(17,24,38,.55);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .distance .label{ color:rgba(232,240,247,.70); font-size:12px; }
    .distance .value{ font-size:20px; font-weight:900; letter-spacing:.2px; }

    .arrowWrap{
      border-radius:18px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(17,24,38,.35);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:16px;
      position:relative;
      overflow:hidden;
      min-height: clamp(280px, 52vh, 520px);
    }
    /* Responsive arrow scaling rules */
    .arrow{
      width: min(520px, 80vmin);
      height: min(520px, 80vmin);
      max-width: 520px;
      max-height: 520px;
      border-radius:999px;
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
      background:
        radial-gradient(circle at 50% 50%, rgba(255,255,255,.06), rgba(255,255,255,.02) 55%, rgba(0,0,0,0) 70%),
        radial-gradient(circle at 50% 50%, rgba(96,165,250,.14), rgba(0,0,0,0) 60%);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.02);
    }
    .ring{
      position:absolute;
      inset:10%;
      border-radius:999px;
      border:1px dashed rgba(255,255,255,.16);
      opacity:.55;
    }
    .north{
      position:absolute;
      top:10px;
      font-size:12px;
      letter-spacing:.35px;
      color:rgba(232,240,247,.7);
    }

    /* SVG arrow */
    .needle{
      width: min(320px, 46vmin);
      height: min(320px, 46vmin);
      transform: rotate(0deg);
      transform-origin: 50% 50%;
      transition: transform .08s linear;
      filter: drop-shadow(0 12px 26px rgba(0,0,0,.4));
    }

    .subInfo{
      position:absolute;
      left:12px;
      right:12px;
      bottom:12px;
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:10px;
      pointer-events:none;
    }
    .mini{
      font-size:12px;
      color:rgba(232,240,247,.72);
      background:rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      padding:8px 10px;
      border-radius:12px;
      backdrop-filter: blur(8px);
      max-width: 70%;
    }
    .mini b{ color:rgba(232,240,247,.92); }

    .footer{
      padding:12px 18px 16px;
      border-top:1px solid rgba(255,255,255,.08);
      color:rgba(232,240,247,.55);
      font-size:12px;
      display:flex;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .linklike{ color:rgba(96,165,250,.92); text-decoration:none; pointer-events:auto; }

    @media (max-width: 480px){
      .arrowWrap{ min-height: 46vh; }
      .arrow{ width: min(440px, 92vmin); height: min(440px, 92vmin); }
      .needle{ width: min(300px, 64vmin); height: min(300px, 64vmin); }
    }
    @media (min-width: 768px) and (max-width: 1024px){
      .arrowWrap{ min-height: 56vh; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>PlusCode Compass Navigator</h1>
      <div class="pill" id="pill"><span class="dot" id="pillDot"></span><span id="pillText">Checking…</span></div>
    </header>

    <main>
      <div class="stack">
        <!-- 1) Plus Code input -->
        <div class="field">
          <label for="plusCode">Plus Code</label>
          <input id="plusCode" autocomplete="off" placeholder="e.g. 7J4V+5W Bengaluru or 849VCWC8+R9" />
        </div>

        <!-- 2) Start Navigation button (and permission CTAs) -->
        <div class="actions">
          <button class="primary" id="startBtn" disabled>Start Navigation</button>
          <button class="ghost" id="stopBtn" style="display:none">Stop</button>
          <button id="enableLocationBtn">Enable Location</button>
          <button id="enableCompassBtn" style="display:none">Enable Compass</button>
        </div>

        <div class="status" id="statusBox">
          <strong>Status:</strong> Loading…
        </div>

        <!-- 3) Distance -->
        <div class="distance">
          <div>
            <div class="label">Distance to location</div>
            <div class="value" id="distanceText">—</div>
          </div>
          <div style="text-align:right">
            <div class="label">Arrival</div>
            <div class="value" id="arrivalText" style="font-size:14px; font-weight:800; opacity:.9">—</div>
          </div>
        </div>

        <!-- 4) Compass arrow -->
        <div class="arrowWrap">
          <div class="arrow" aria-label="Compass">
            <div class="ring"></div>
            <div class="north">N</div>
            <svg class="needle" id="needle" viewBox="0 0 200 200" role="img" aria-label="Direction arrow">
              <defs>
                <linearGradient id="g" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="0" stop-color="#e8f0f7" stop-opacity="0.95"/>
                  <stop offset="1" stop-color="#60a5fa" stop-opacity="0.95"/>
                </linearGradient>
              </defs>
              <circle cx="100" cy="100" r="10" fill="rgba(232,240,247,.9)" />
              <path d="M100 18 L134 120 L100 104 L66 120 Z" fill="url(#g)"/>
              <path d="M100 182 L120 120 L100 132 L80 120 Z" fill="rgba(255,255,255,.15)"/>
            </svg>

            <div class="subInfo">
              <div class="mini" id="miniLeft">Heading: —</div>
              <div class="mini" id="miniRight">Bearing: —</div>
            </div>
          </div>
        </div>
      </div>
    </main>

    <div class="footer">
      <div>Privacy: On-device only. No tracking. No backend.</div>
      <a class="linklike" href="#" id="toggleDebug">Debug</a>
    </div>
  </div>

<script>
/***********************
 * PlusCode Compass Navigator
 * Single-file HTML/CSS/JS
 ***********************/

// ---------- Config ----------
const ARRIVAL_THRESHOLD_M = 15;
const HEADING_ALPHA = 0.20;   // 0.15–0.25 (PRD)
const DIST_ALPHA = 0.22;
const UI_FPS = 45;            // 30–60 fps (PRD)

// ---------- State ----------
let debug = false;
let appState = -1; // -1 gate, 0 idle, 1 requesting, 2 navigating, 3 arrived, 4 error

let dest = null; // {lat,lng}

let watchId = null;
let lastPos = null; // {lat,lng,acc,timestamp}

let rawHeading = null;        // 0..360
let smoothHeading = null;     // 0..360
let headingHistory = [];

let rawDistance = null;
let smoothDistance = null;

let bearingDeg = null;

let orientationActive = false;
let compassSupported = false;
let locationGranted = false;

let renderTimer = null;

// ---------- DOM ----------
const el = {
  pill: document.getElementById('pill'),
  pillDot: document.getElementById('pillDot'),
  pillText: document.getElementById('pillText'),

  plusCode: document.getElementById('plusCode'),
  startBtn: document.getElementById('startBtn'),
  stopBtn: document.getElementById('stopBtn'),
  enableLocationBtn: document.getElementById('enableLocationBtn'),
  enableCompassBtn: document.getElementById('enableCompassBtn'),

  statusBox: document.getElementById('statusBox'),
  distanceText: document.getElementById('distanceText'),
  arrivalText: document.getElementById('arrivalText'),

  needle: document.getElementById('needle'),
  miniLeft: document.getElementById('miniLeft'),
  miniRight: document.getElementById('miniRight'),

  toggleDebug: document.getElementById('toggleDebug'),
};

// ---------- Helpers ----------
function setPill(mode, text){
  // mode: ok | warn | bad
  el.pillDot.className = 'dot ' + (mode === 'ok' ? 'ok' : mode === 'bad' ? 'bad' : '');
  el.pillText.textContent = text;
}

function setStatus(type, html){
  el.statusBox.className = 'status' + (type ? ' ' + type : '');
  el.statusBox.innerHTML = html;
}

function isHTTPS(){
  return window.isSecureContext && location.protocol === 'https:';
}

function clampAngle360(a){
  let x = a % 360;
  if (x < 0) x += 360;
  return x;
}

// Signed smallest delta from a->b in degrees (-180..180]
function angleDelta(a, b){
  let d = (b - a + 540) % 360 - 180;
  return d;
}

function smoothAngle(prev, next, alpha){
  if (prev == null) return clampAngle360(next);
  const d = angleDelta(prev, next);
  return clampAngle360(prev + alpha * d);
}

function formatDistance(m){
  if (m == null || !isFinite(m)) return '—';
  if (m >= 1000) return (m/1000).toFixed(1) + ' km';
  return Math.round(m) + ' m';
}

function nowMs(){ return performance.now(); }

// ---------- Geo math ----------
function toRad(d){ return d * Math.PI / 180; }
function toDeg(r){ return r * 180 / Math.PI; }

// Bearing from (lat1,lng1) to (lat2,lng2)
function computeBearing(lat1, lon1, lat2, lon2){
  const φ1 = toRad(lat1), φ2 = toRad(lat2);
  const Δλ = toRad(lon2 - lon1);
  const y = Math.sin(Δλ) * Math.cos(φ2);
  const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
  const θ = Math.atan2(y, x);
  return clampAngle360(toDeg(θ));
}

// Haversine distance meters
function haversine(lat1, lon1, lat2, lon2){
  const R = 6371000;
  const φ1 = toRad(lat1), φ2 = toRad(lat2);
  const Δφ = toRad(lat2-lat1);
  const Δλ = toRad(lon2-lon1);
  const a = Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
  const c = 2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R*c;
}

// ---------- Plus Code decoding (local, no deps) ----------
// Minimal Open Location Code decode implementation (sufficient for full codes).
// Supports full plus codes like: 849VCWC8+R9
// Short codes require locality (out of scope without geocoder) -> we show an error.

const OLC_ALPHABET = '23456789CFGHJMPQRVWX';
const SEPARATOR = '+';
const SEPARATOR_POSITION = 8;
const PADDING_CHAR = '0';
const GRID_COLUMNS = 4;
const GRID_ROWS = 5;

function isValidPlusCode(input){
  if (!input) return false;
  const code = input.trim().toUpperCase();
  if (!code.includes(SEPARATOR)) return false;
  // basic format sanity
  const sep = code.indexOf(SEPARATOR);
  if (sep < 2 || sep > 10) return false;
  return true;
}

function cleanPlusCode(input){
  // Accept "CODE locality". Extract token containing '+'
  const parts = input.trim().toUpperCase().split(/\s+/);
  const token = parts.find(p => p.includes(SEPARATOR));
  return token || input.trim().toUpperCase();
}

function stripNonCodeChars(code){
  return code.replace(/[^0-9A-Z+]/g,'');
}

function isFullCode(code){
  const c = stripNonCodeChars(code);
  const sep = c.indexOf(SEPARATOR);
  if (sep !== SEPARATOR_POSITION) return false;
  // after separator should be at least 2 chars for full precision
  return c.length >= SEPARATOR_POSITION + 3;
}

function decodePlusCode(input){
  const token = cleanPlusCode(input);
  const code = stripNonCodeChars(token);

  if (!isValidPlusCode(code)) throw new Error("That Plus Code doesn’t look valid");

  // Short codes need a reference location -> not possible offline.
  if (!isFullCode(code)){
    throw new Error('Short Plus Codes require a locality lookup. Please use a full Plus Code like 849VCWC8+R9.');
  }

  const normalized = code.replace(SEPARATOR,'');

  // Pair section (first 10 chars possible, separator at 8 => pairs cover up to 10)
  const pairCodeLength = Math.min(normalized.length, 10);
  const pairCode = normalized.slice(0, pairCodeLength);

  let latLo = -90, lngLo = -180;
  let latPlace = 20, lngPlace = 20;

  // Decode pairs
  for (let i=0; i<pairCode.length; i+=2){
    const latCh = pairCode[i];
    const lngCh = pairCode[i+1];
    const latVal = OLC_ALPHABET.indexOf(latCh);
    const lngVal = OLC_ALPHABET.indexOf(lngCh);
    if (latVal < 0 || lngVal < 0) throw new Error('Unable to decode Plus Code. Try using a full Plus Code.');

    latLo += latVal * latPlace;
    lngLo += lngVal * lngPlace;

    latPlace /= 20;
    lngPlace /= 20;
  }

  // Grid refinement (after 10 chars)
  let grid = normalized.slice(pairCodeLength);
  if (grid.length > 0){
    let latPlaceGrid = latPlace;
    let lngPlaceGrid = lngPlace;

    for (let i=0; i<grid.length; i++){
      const ch = grid[i];
      const v = OLC_ALPHABET.indexOf(ch);
      if (v < 0) throw new Error('Unable to decode Plus Code. Try using a full Plus Code.');

      const row = Math.floor(v / GRID_COLUMNS);
      const col = v % GRID_COLUMNS;

      latPlaceGrid /= GRID_ROWS;
      lngPlaceGrid /= GRID_COLUMNS;

      latLo += row * latPlaceGrid;
      lngLo += col * lngPlaceGrid;
    }
    latPlace = latPlaceGrid;
    lngPlace = lngPlaceGrid;
  }

  // Center of decoded cell
  const lat = latLo + latPlace/2;
  const lng = lngLo + lngPlace/2;
  return { lat, lng };
}

// ---------- Permissions / Sensors ----------
async function refreshPermissionState(){
  locationGranted = false;

  if (!('geolocation' in navigator)){
    setStateError('No GPS support on this browser/device.');
    return;
  }

  // Try permissions API (not always supported)
  try{
    if (navigator.permissions && navigator.permissions.query){
      const p = await navigator.permissions.query({ name: 'geolocation' });
      locationGranted = (p.state === 'granted');
      p.onchange = () => refreshPermissionState();
    }
  }catch(_){
    // ignore
  }

  updateStartButtonState();
}

function updateStartButtonState(){
  const httpsOk = isHTTPS();
  const plusOk = isValidPlusCode(el.plusCode.value);

  const canStart = httpsOk && locationGranted && plusOk;
  el.startBtn.disabled = !canStart || appState === 1;
}

async function requestLocationPermission(){
  if (!isHTTPS()){
    setStateError('This app requires HTTPS to access location and compass permissions.');
    return;
  }

  setStatus('warn', '<strong>Location permission:</strong> Requesting…');

  return new Promise((resolve) => {
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        locationGranted = true;
        setStatus('ok', '<strong>Location permission granted.</strong> You can start navigation.');
        resolve(true);
        updateStartButtonState();
      },
      (err) => {
        locationGranted = false;
        setStatus('bad', '<strong>Location access denied.</strong> Please enable location permissions in your browser settings, then Retry.');
        resolve(false);
        updateStartButtonState();
      },
      { enableHighAccuracy: true, timeout: 8000, maximumAge: 0 }
    );
  });
}

async function requestCompassPermissionIfNeeded(){
  // iOS requires user gesture + DeviceOrientationEvent.requestPermission
  const DOE = window.DeviceOrientationEvent;
  if (!DOE) return false;

  if (typeof DOE.requestPermission === 'function'){
    try{
      const res = await DOE.requestPermission();
      return res === 'granted';
    }catch(_){
      return false;
    }
  }
  return true; // Android/others
}

function startOrientationTracking(){
  const handler = (event) => {
    // Prefer iOS absolute compass heading if available
    let heading = null;
    if (typeof event.webkitCompassHeading === 'number'){
      // iOS Safari: 0..360 (0 = north)
      heading = event.webkitCompassHeading;
    } else if (event.absolute === true || event.absolute === undefined){
      // Many Android browsers: alpha = 0 when device faces north (but depends)
      // Convert alpha to compass heading: heading = 360 - alpha
      if (typeof event.alpha === 'number'){
        heading = 360 - event.alpha;
      }
    }

    if (heading == null || !isFinite(heading)) return;

    // Screen orientation compensation
    // When phone rotated, we should compensate arrow to match world.
    // Use Screen Orientation API when available.
    let screenAngle = 0;
    try{
      if (screen.orientation && typeof screen.orientation.angle === 'number') screenAngle = screen.orientation.angle;
      else if (typeof window.orientation === 'number') screenAngle = window.orientation;
    }catch(_){ /* ignore */ }

    heading = clampAngle360(heading + screenAngle);

    rawHeading = clampAngle360(heading);
    smoothHeading = smoothAngle(smoothHeading, rawHeading, HEADING_ALPHA);

    // For optional "Accuracy" estimation via variance
    headingHistory.push(smoothHeading);
    if (headingHistory.length > 20) headingHistory.shift();
  };

  window.addEventListener('deviceorientation', handler, true);
  window.addEventListener('deviceorientationabsolute', handler, true);

  orientationActive = true;
  compassSupported = true; // will downgrade if no values arrive

  // If after 2 seconds we still don't have heading -> mark unsupported
  setTimeout(() => {
    if (rawHeading == null){
      compassSupported = false;
      orientationActive = false;
      setStatus('warn', '<strong>Compass unavailable.</strong> Distance-only mode active.');
      el.enableCompassBtn.style.display = 'none';
    }
  }, 2000);
}

function stopOrientationTracking(){
  // No easy remove because we used anonymous handler in this simple build.
  // Since it’s a single-file MVP, we rely on state gating and stop render loop.
  orientationActive = false;
}

// ---------- Navigation ----------
function startGPS(){
  if (watchId != null) return;
  watchId = navigator.geolocation.watchPosition(
    (pos) => {
      lastPos = {
        lat: pos.coords.latitude,
        lng: pos.coords.longitude,
        acc: pos.coords.accuracy,
        timestamp: pos.timestamp
      };

      if (dest){
        bearingDeg = computeBearing(lastPos.lat, lastPos.lng, dest.lat, dest.lng);
        rawDistance = haversine(lastPos.lat, lastPos.lng, dest.lat, dest.lng);
        smoothDistance = (smoothDistance == null) ? rawDistance : (DIST_ALPHA * rawDistance + (1-DIST_ALPHA) * smoothDistance);
      }
    },
    (err) => {
      setStateError('Location unavailable. Try moving outdoors or enabling GPS.');
    },
    {
      enableHighAccuracy: true,
      maximumAge: 500,
      timeout: 10000
    }
  );
}

function stopGPS(){
  if (watchId != null){
    navigator.geolocation.clearWatch(watchId);
    watchId = null;
  }
}

function renderLoop(){
  const frameMs = 1000 / UI_FPS;
  if (renderTimer) clearInterval(renderTimer);

  renderTimer = setInterval(() => {
    // Update distance UI
    el.distanceText.textContent = formatDistance(smoothDistance);

    // Arrival
    if (smoothDistance != null && smoothDistance < ARRIVAL_THRESHOLD_M){
      if (appState !== 3){
        appState = 3;
        setStatus('ok', "<strong>You’ve arrived ✅</strong> You are within 15 m of the target.");
      }
      el.arrivalText.textContent = 'Arrived ✅';
    } else {
      el.arrivalText.textContent = '—';
    }

    // Bearing / Heading -> arrow rotation
    let headingText = 'Heading: —';
    if (smoothHeading != null) headingText = `Heading: <b>${Math.round(smoothHeading)}°</b>`;

    let bearingText = 'Bearing: —';
    if (bearingDeg != null) bearingText = `Bearing: <b>${Math.round(bearingDeg)}°</b>`;

    // Optional "Accuracy" signal: variance of heading history
    let accLabel = '';
    if (headingHistory.length >= 10){
      const avg = headingHistory.reduce((a,b)=>a+b,0)/headingHistory.length;
      const variance = headingHistory.reduce((a,b)=>a+(angleDelta(avg,b)**2),0)/headingHistory.length;
      if (variance > 400) accLabel = ' · Accuracy: Low';
      else if (variance > 120) accLabel = ' · Accuracy: Medium';
      else accLabel = ' · Accuracy: Good';
    }

    el.miniLeft.innerHTML = headingText + (debug ? accLabel : '');
    el.miniRight.innerHTML = bearingText;

    // rotate needle
    if (bearingDeg != null && smoothHeading != null && compassSupported){
      const rotation = clampAngle360(bearingDeg - smoothHeading);
      el.needle.style.transform = `rotate(${rotation}deg)`;

      // Calibration helper
      if (debug === false && headingHistory.length >= 10){
        const avg = headingHistory.reduce((a,b)=>a+b,0)/headingHistory.length;
        const variance = headingHistory.reduce((a,b)=>a+(angleDelta(avg,b)**2),0)/headingHistory.length;
        if (variance > 350){
          setStatus('warn', '<strong>Tip:</strong> If the arrow feels unstable, move your phone in a figure-8 to calibrate.');
        }
      }
    } else {
      // distance-only / placeholder
      el.needle.style.transform = 'rotate(0deg)';
    }

    // debug footer
    if (debug && dest && lastPos){
      const extra = `Destination: ${dest.lat.toFixed(6)}, ${dest.lng.toFixed(6)} · GPS acc: ${Math.round(lastPos.acc)}m`;
      // Don’t overwrite critical warnings
      if (!el.statusBox.className.includes('bad')){
        setStatus('ok', `<strong>Navigating.</strong> ${extra}`);
      }
    }

  }, frameMs);
}

function stopRenderLoop(){
  if (renderTimer){
    clearInterval(renderTimer);
    renderTimer = null;
  }
}

// ---------- App state mgmt ----------
function setStateError(message){
  appState = 4;
  setPill('bad', 'Error');
  setStatus('bad', `<strong>Error:</strong> ${escapeHTML(message)}<br/><br/><span style="opacity:.9">If this is a permissions issue, try: Enable Location → reload page.</span>`);
  el.startBtn.disabled = true;
}

function setGateState(){
  // HTTPS gate
  if (!isHTTPS()){
    setPill('bad', 'HTTPS required');
    setStatus('bad', '<strong>HTTPS required.</strong> This app requires HTTPS to access location and compass permissions.');
    el.startBtn.disabled = true;
    return;
  }

  setPill('warn', 'Permissions');
  setStatus('warn', '<strong>Location permission is required to navigate.</strong> Tap Enable Location.');
}

function escapeHTML(s){
  return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
}

// ---------- Events ----------
el.plusCode.addEventListener('input', () => {
  updateStartButtonState();
});

el.enableLocationBtn.addEventListener('click', async () => {
  appState = 1;
  setPill('warn','Requesting…');
  await requestLocationPermission();
  await refreshPermissionState();
  appState = 0;
  if (locationGranted){
    setPill('ok','Ready');
    // If desktop, compass likely absent
    setStatus('ok', '<strong>Ready.</strong> Enter a Plus Code and tap Start Navigation.');
  } else {
    setGateState();
  }
});

el.enableCompassBtn.addEventListener('click', async () => {
  const ok = await requestCompassPermissionIfNeeded();
  if (!ok){
    compassSupported = false;
    setStatus('warn', '<strong>Compass permission denied.</strong> Distance-only mode active.');
  } else {
    startOrientationTracking();
    setStatus('ok', '<strong>Compass enabled.</strong> Start navigation.');
  }
});

el.startBtn.addEventListener('click', async () => {
  try{
    if (!isHTTPS()) throw new Error('This app requires HTTPS to use location and compass.');
    if (!locationGranted) throw new Error('Location permission is required to navigate.');

    const input = el.plusCode.value.trim();
    if (!input) throw new Error('Please enter a Plus Code');
    if (!isValidPlusCode(input)) throw new Error("That Plus Code doesn’t look valid");

    dest = decodePlusCode(input);

    appState = 1;
    setPill('warn','Requesting…');
    setStatus('warn', '<strong>Requesting permissions…</strong>');

    // Request compass permission on iOS during user gesture
    const ok = await requestCompassPermissionIfNeeded();
    if (ok){
      el.enableCompassBtn.style.display = 'none';
      startOrientationTracking();
    } else {
      compassSupported = false;
      el.enableCompassBtn.style.display = 'none';
    }

    // Start GPS tracking
    startGPS();

    // Start render loop
    renderLoop();

    appState = 2;
    setPill('ok','Navigating');
    setStatus('ok', '<strong>Navigating.</strong> Walk in the direction of the arrow.');

    // UI controls
    el.stopBtn.style.display = '';
    el.enableLocationBtn.style.display = 'none';

    // Lock input (optional per PRD)
    el.plusCode.disabled = true;

  }catch(err){
    setStateError(err.message || 'Unknown error');
  }
});

el.stopBtn.addEventListener('click', () => {
  stopGPS();
  stopRenderLoop();
  stopOrientationTracking();

  dest = null;
  lastPos = null;
  rawHeading = null;
  smoothHeading = null;
  headingHistory = [];
  rawDistance = null;
  smoothDistance = null;
  bearingDeg = null;

  appState = 0;
  setPill('ok','Ready');
  setStatus('ok', '<strong>Stopped.</strong> You can enter another Plus Code.');

  el.plusCode.disabled = false;
  el.stopBtn.style.display = 'none';
  el.enableLocationBtn.style.display = '';
  el.enableLocationBtn.textContent = 'Enable Location';
  el.distanceText.textContent = '—';
  el.arrivalText.textContent = '—';
  el.needle.style.transform = 'rotate(0deg)';

  updateStartButtonState();
});

el.toggleDebug.addEventListener('click', (e) => {
  e.preventDefault();
  debug = !debug;
  el.toggleDebug.textContent = debug ? 'Debug: ON' : 'Debug';
  if (debug){
    setStatus('ok', '<strong>Debug enabled.</strong> You will see decoded destination + GPS accuracy.');
  } else {
    if (appState === 2) setStatus('ok', '<strong>Navigating.</strong> Walk in the direction of the arrow.');
  }
});

// ---------- Boot ----------
(function init(){
  // HTTPS requirement gate
  if (!isHTTPS()){
    setPill('bad','HTTPS required');
    setStatus('bad', '<strong>HTTPS required.</strong> This app requires HTTPS to access location and compass permissions.');
    el.enableLocationBtn.style.display = 'none';
    el.startBtn.disabled = true;
    return;
  }

  setPill('warn','Permissions');
  setGateState();

  // Desktop sensor limitation handling: show compass CTA only if supported
  const DOE = window.DeviceOrientationEvent;
  if (DOE){
    el.enableCompassBtn.style.display = '';
  }

  refreshPermissionState().then(() => {
    if (locationGranted){
      setPill('ok','Ready');
      setStatus('ok', '<strong>Ready.</strong> Enter a Plus Code and tap Start Navigation.');
    }
  });

  // If permissions are granted but user on desktop with no compass: allow distance-only.
  // We detect compass support once navigation starts.
})();
</script>
</body>
</html>
